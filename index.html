<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Podcast Recommender</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 900px;
      margin: 0 auto;
      background: white;
      border-radius: 20px;
      padding: 40px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    
    h1 { 
      color: #333; 
      text-align: center;
      margin-bottom: 10px;
      font-size: 2.5em;
    }
    
    .subtitle {
      text-align: center;
      color: #666;
      margin-bottom: 30px;
    }
    
    .controls-container {
      display: flex;
      gap: 15px;
      margin-bottom: 30px;
      align-items: stretch;
    }
    
    #search-container {
      flex: 1;
      position: relative;
    }
    
    #search { 
      width: 100%; 
      padding: 16px 20px; 
      border-radius: 50px; 
      border: 2px solid #e0e0e0; 
      font-size: 16px; 
      transition: all 0.3s;
      background: #f8f8f8;
      height: 100%;
    }
    
    #search:focus {
      outline: none;
      border-color: #667eea;
      background: white;
      box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
    }
    
    .language-filter {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    .filter-btn {
      padding: 12px 20px;
      border: 2px solid #e0e0e0;
      background: #f8f8f8;
      border-radius: 25px;
      cursor: pointer;
      font-size: 15px;
      transition: all 0.3s;
      white-space: nowrap;
      color: #666;
      font-weight: 500;
    }
    
    .filter-btn:hover {
      background: #f0f0f0;
      transform: translateY(-1px);
    }
    
    .filter-btn.active {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border-color: #667eea;
    }
    
    @media (max-width: 768px) {
      .controls-container {
        flex-direction: column;
      }
      
      .language-filter {
        justify-content: center;
      }
    }
    
    #init-message {
      text-align: center;
      padding: 40px;
      color: #666;
      font-size: 18px;
    }
    
    #loading {
      text-align: center;
      padding: 40px;
      display: none;
    }
    
    .spinner {
      border: 3px solid #f3f3f3;
      border-top: 3px solid #667eea;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    #error {
      background: #fee;
      color: #c33;
      padding: 16px;
      border-radius: 10px;
      margin: 20px 0;
      display: none;
      text-align: center;
    }
    
    #status {
      text-align: center;
      color: #666;
      font-size: 14px;
      margin: 10px 0;
      min-height: 20px;
    }
    
    #results { 
      margin-top: 30px;
    }
    
    .result-item { 
      background: #f9f9f9; 
      padding: 20px; 
      border-radius: 12px; 
      margin-bottom: 16px; 
      display: flex; 
      gap: 16px;
      border: 1px solid #e0e0e0;
      transition: all 0.3s;
    }
    
    .result-item:hover {
      transform: translateX(5px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      background: white;
    }
    
    .podcast-image { 
      width: 80px; 
      height: 80px; 
      border-radius: 8px; 
      object-fit: cover;
      flex-shrink: 0;
      background: #e0e0e0;
    }
    
    .podcast-info {
      flex: 1;
      min-width: 0;
    }
    
    .podcast-title {
      color: #667eea;
      text-decoration: none;
      font-weight: 600;
      font-size: 18px;
      display: block;
      margin-bottom: 8px;
      line-height: 1.3;
    }
    
    .podcast-title:hover {
      text-decoration: underline;
    }
    
    .podcast-description {
      color: #666;
      font-size: 14px;
      line-height: 1.5;
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }
    
    .score-badge {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      align-self: flex-start;
      white-space: nowrap;
    }
    
    .no-results {
      text-align: center;
      padding: 60px 20px;
      color: #999;
      font-size: 18px;
    }
    
    .no-results svg {
      width: 80px;
      height: 80px;
      margin-bottom: 20px;
      opacity: 0.5;
    }
    
    .language-info {
      font-size: 11px;
      color: #999;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üéß AI Podcast Recommender</h1>
    <p class="subtitle">Search through thousands of podcast episodes using AI</p>
    
    <div class="controls-container">
      <div id="search-container">
        <input 
          id="search" 
          type="text"
          placeholder="Try searching for: technology, comedy, history, science..." 
          autocomplete="off"
        />
      </div>
      <div class="language-filter">
        <button class="filter-btn active" data-filter="all">All</button>
        <button class="filter-btn" data-filter="simplified">ÁÆÄ‰Ωì‰∏≠Êñá</button>
        <button class="filter-btn" data-filter="traditional">ÁπÅÈ´î‰∏≠Êñá</button>
      </div>
    </div>
    
    <div id="init-message">
      <div class="spinner"></div>
      Loading AI models... This may take a moment on first visit.
    </div>
    
    <div id="status"></div>
    <div id="loading">
      <div class="spinner"></div>
      Searching podcast database...
    </div>
    <div id="error"></div>
    <div id="results"></div>
  </div>

  <script type="module">
    // Simple configuration for GitHub Pages
    const CONFIG = {
      SHARD_COUNT: 200,        // Total number of shard files
      TOP_K: 30,               // Number of candidates to consider
      FINAL_K: 10,             // Number of results to display
      DEBOUNCE_DELAY: 600,     // Typing delay in milliseconds
      BATCH_SIZE: 5,           // Shards to load simultaneously
      MODEL_NAME: 'Xenova/all-MiniLM-L6-v2'  // Embedding model
    };

    // Language filter configuration
    const LANGUAGE_FILTERS = {
      // Languages to exclude completely
      EXCLUDED: [
        'zh-rtw', 'zh-hant', 'zh-Hant-', 'zh-Hans-', 'zh-Hant', 
        'en-us,zh', 'zh-US', 'eng, zho', 'zh-sg', 'zh-HK', 'zh-hk', 'zh-Ha'
      ],
      
      // Simplified Chinese variants
      SIMPLIFIED: [
        'zh-CN', 'zh_CN', 'zh-cn', 'zh', 'Zh', 'ZH', 
        'zh-Hans', 'zh-hans', 'zh-ZH', 'zh-zh', 'zho'
      ],
      
      // Traditional Chinese variants
      TRADITIONAL: [
        'zh-tw', 'zh-TW', 'zh_TW', 'zh_tw', 'zh-MO'
      ]
    };

    let embedder = null;
    let isInitializing = false;
    let isSearching = false;
    let searchAbortController = null;
    let currentLanguageFilter = 'all';
    let lastSearchQuery = '';

    // Import transformers library with fallback
    async function loadTransformers() {
      try {
        const { pipeline, env } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2/dist/transformers.min.js');
        
        // Configure for browser usage
        env.allowLocalModels = false;
        env.useBrowserCache = true;
        env.remoteURL = 'https://huggingface.co/';
        
        return { pipeline, env };
      } catch (error) {
        console.error('Failed to load transformers:', error);
        // Try alternative CDN
        try {
          const { pipeline, env } = await import('https://unpkg.com/@xenova/transformers@2.17.2/dist/transformers.min.js');
          env.allowLocalModels = false;
          env.useBrowserCache = true;
          return { pipeline, env };
        } catch (fallbackError) {
          throw new Error('Could not load AI models from any CDN');
        }
      }
    }

    // Initialize the embedding model
    async function initializeModels() {
      if (isInitializing || embedder) return embedder;
      
      isInitializing = true;
      const initMessage = document.getElementById('init-message');
      
      try {
        const { pipeline } = await loadTransformers();
        
        console.log('Loading embedding model...');
        embedder = await pipeline('feature-extraction', CONFIG.MODEL_NAME);
        
        console.log('Model loaded successfully');
        initMessage.style.display = 'none';
        document.getElementById('search').disabled = false;
        updateStatus('Ready to search! Start typing...');
        
        return embedder;
      } catch (error) {
        console.error('Model initialization failed:', error);
        initMessage.innerHTML = `
          <div style="color: #e74c3c;">
            <p><strong>Failed to load AI models</strong></p>
            <p style="margin-top: 10px; font-size: 14px;">
              ${error.message}<br>
              Please check your internet connection and refresh the page.
            </p>
          </div>
        `;
        document.getElementById('search').disabled = true;
        throw error;
      } finally {
        isInitializing = false;
      }
    }

    // Check if an item should be filtered based on language
    function shouldIncludeItem(item) {
      const itemLanguage = (item.language || '').toLowerCase().trim();
      
      // First, exclude completely blocked languages
      for (const excluded of LANGUAGE_FILTERS.EXCLUDED) {
        if (itemLanguage === excluded.toLowerCase()) {
          return false;
        }
      }
      
      // If "All" is selected, include everything not in excluded list
      if (currentLanguageFilter === 'all') {
        return true;
      }
      
      // Check specific language filters
      if (currentLanguageFilter === 'simplified') {
        for (const lang of LANGUAGE_FILTERS.SIMPLIFIED) {
          if (itemLanguage === lang.toLowerCase()) {
            return true;
          }
        }
        return false;
      }
      
      if (currentLanguageFilter === 'traditional') {
        for (const lang of LANGUAGE_FILTERS.TRADITIONAL) {
          if (itemLanguage === lang.toLowerCase()) {
            return true;
          }
        }
        return false;
      }
      
      return true;
    }

    // Calculate cosine similarity between two vectors
    function cosineSimilarity(a, b) {
      if (!a || !b || a.length !== b.length) return 0;
      
      let dotProduct = 0;
      let normA = 0;
      let normB = 0;
      
      for (let i = 0; i < a.length; i++) {
        dotProduct += a[i] * b[i];
        normA += a[i] * a[i];
        normB += b[i] * b[i];
      }
      
      if (normA === 0 || normB === 0) return 0;
      return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
    }

    // Load a shard file with retry logic
    async function loadShard(shardId, retries = 2) {
      for (let i = 0; i <= retries; i++) {
        try {
          const response = await fetch(`shards/shard_${shardId}.json`, {
            cache: 'force-cache'  // Use browser cache aggressively
          });
          
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          
          const data = await response.json();
          return { shardId, data, error: null };
        } catch (error) {
          if (i === retries) {
            console.warn(`Failed to load shard_${shardId} after ${retries + 1} attempts`);
            return { shardId, data: null, error };
          }
          // Wait before retry
          await new Promise(resolve => setTimeout(resolve, 100 * (i + 1)));
        }
      }
    }

    // Main search function
    async function performSearch(query) {
      if (!query || query.trim().length < 2) {
        document.getElementById('results').innerHTML = '';
        updateStatus('');
        return;
      }

      // Save the current query
      lastSearchQuery = query;

      // Cancel previous search if still running
      if (searchAbortController) {
        searchAbortController.abort();
      }
      searchAbortController = new AbortController();

      if (isSearching) return;
      isSearching = true;

      showLoading(true);
      updateStatus('');
      document.getElementById('results').innerHTML = '';

      try {
        // Ensure model is loaded
        if (!embedder) {
          await initializeModels();
          if (!embedder) return;
        }

        console.log('Generating embedding for query:', query);
        console.log('Language filter:', currentLanguageFilter);
        
        // Generate query embedding
        const output = await embedder(query, { 
          pooling: 'mean', 
          normalize: true 
        });
        
        // Convert to array
        const queryVector = Array.from(output.data);
        
        console.log('Query embedding generated, searching shards...');
        
        // Track top results
        const topResults = [];
        let processedShards = 0;
        let totalItems = 0;
        let filteredCount = 0;
        let failedShards = 0;

        // Process shards in batches
        for (let i = 0; i < CONFIG.SHARD_COUNT; i += CONFIG.BATCH_SIZE) {
          if (searchAbortController.signal.aborted) break;
          
          const batch = [];
          for (let j = i; j < Math.min(i + CONFIG.BATCH_SIZE, CONFIG.SHARD_COUNT); j++) {
            batch.push(loadShard(j));
          }
          
          const shardResults = await Promise.all(batch);
          
          for (const { shardId, data, error } of shardResults) {
            if (error) {
              failedShards++;
              continue;
            }
            
            if (!data || !Array.isArray(data)) continue;
            
            processedShards++;
            
            for (const item of data) {
              if (!item || !item.embedding || !Array.isArray(item.embedding)) continue;
              
              totalItems++;
              
              // Apply language filter
              if (!shouldIncludeItem(item)) {
                filteredCount++;
                continue;
              }
              
              const score = cosineSimilarity(queryVector, item.embedding);
              
              // Keep top K results
              if (topResults.length < CONFIG.TOP_K) {
                topResults.push({ ...item, score, shardId });
              } else {
                // Find minimum score
                let minIdx = 0;
                for (let k = 1; k < topResults.length; k++) {
                  if (topResults[k].score < topResults[minIdx].score) {
                    minIdx = k;
                  }
                }
                // Replace if better
                if (score > topResults[minIdx].score) {
                  topResults[minIdx] = { ...item, score, shardId };
                }
              }
            }
          }
          
          // Update progress
          if (processedShards % 10 === 0 || processedShards === CONFIG.SHARD_COUNT) {
            const filterText = currentLanguageFilter !== 'all' 
              ? ` (${filteredCount} filtered by language)` 
              : '';
            updateStatus(`Searched ${processedShards} of ${CONFIG.SHARD_COUNT} shards${filterText}...`);
          }
        }

        console.log(`Search complete: ${processedShards} shards, ${totalItems} items, ${filteredCount} filtered, ${failedShards} failed`);
        
        if (topResults.length === 0) {
          displayNoResults(filteredCount > 0);
          return;
        }

        // Sort and rerank results
        topResults.sort((a, b) => b.score - a.score);
        const reranked = rerankResults(query, topResults);
        
        // Display top results
        displayResults(reranked.slice(0, CONFIG.FINAL_K));
        
        const filterInfo = currentLanguageFilter !== 'all' 
          ? ` (${filteredCount} filtered)` 
          : '';
        updateStatus(`Found ${reranked.length} relevant podcasts${filterInfo}`);
        
      } catch (error) {
        console.error('Search error:', error);
        showError('Search failed. Please try again.');
      } finally {
        showLoading(false);
        isSearching = false;
        searchAbortController = null;
      }
    }

    // Rerank results based on keyword matching
    function rerankResults(query, items) {
      const queryLower = query.toLowerCase();
      const queryWords = queryLower.split(/\s+/).filter(w => w.length > 2);
      
      return items.map(item => {
        let boost = 0;
        
        const title = (item.title || '').toLowerCase();
        const desc = (item.description || '').toLowerCase();
        const creator = (item.creator || '').toLowerCase();
        
        // Exact phrase match
        if (title.includes(queryLower)) boost += 0.4;
        if (desc.includes(queryLower)) boost += 0.2;
        if (creator.includes(queryLower)) boost += 0.15;
        
        // Individual word matches
        for (const word of queryWords) {
          if (title.includes(word)) boost += 0.1;
          if (desc.includes(word)) boost += 0.05;
          if (creator.includes(word)) boost += 0.03;
        }
        
        // Title starts with query
        if (title.startsWith(queryLower)) boost += 0.3;
        
        // Creator starts with query (for searching by podcast name)
        if (creator.startsWith(queryLower)) boost += 0.2;
        
        return {
          ...item,
          finalScore: item.score + boost
        };
      }).sort((a, b) => b.finalScore - a.finalScore);
    }

    // Display search results
    function displayResults(results) {
      const container = document.getElementById('results');
      
      if (!results || results.length === 0) {
        displayNoResults(false);
        return;
      }
      
      container.innerHTML = results.map(item => {
        // Use the correct field names from your JSON structure
        const imageUrl = item.image || 
          'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjgwIiBmaWxsPSIjZTBlMGUwIi8+CiAgPHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIzMCIgZmlsbD0iIzk5OSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZG9taW5hbnQtYmFzZWxpbmU9Im1pZGRsZSI+8J+OpjwvdGV4dD4KPC9zdmc+';
        
        const title = item.title || 'Untitled Episode';
        const description = item.description || 'No description available';
        const creator = item.creator || '';
        const link = item.link || '#';
        const score = Math.round((item.finalScore || item.score || 0) * 100);
        const language = item.language || '';
        
        // Add creator name if available
        const creatorInfo = creator ? `<span style="color: #888; font-size: 12px; display: block; margin-top: 4px;">by ${escapeHtml(creator)}</span>` : '';
        
        // Add language info if available and not "All" filter
        const languageInfo = language && currentLanguageFilter !== 'all' 
          ? `<div class="language-info">Language: ${escapeHtml(language)}</div>` 
          : '';
        
        return `
          <div class="result-item">
            <img 
              src="${imageUrl}" 
              alt="${title}" 
              class="podcast-image"
              loading="lazy"
              onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjgwIiBmaWxsPSIjZTBlMGUwIi8+CiAgPHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIzMCIgZmlsbD0iIzk5OSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZG9taW5hbnQtYmFzZWxpbmU9Im1pZGRsZSI+8J+OpjwvdGV4dD4KPC9zdmc+'"
            />
            <div class="podcast-info">
              <a href="${link}" target="_blank" rel="noopener noreferrer" class="podcast-title">
                ${escapeHtml(title)}
              </a>
              ${creatorInfo}
              <p class="podcast-description">${escapeHtml(description)}</p>
              ${languageInfo}
            </div>
            <div class="score-badge">${score}%</div>
          </div>
        `;
      }).join('');
    }

    // Display no results message
    function displayNoResults(hasFilteredResults = false) {
      const message = hasFilteredResults 
        ? `<p>No matching podcasts found with current language filter</p>
           <p style="font-size: 14px; margin-top: 10px; color: #bbb;">
             Try selecting "All" languages or different search terms
           </p>`
        : `<p>No matching podcasts found</p>
           <p style="font-size: 14px; margin-top: 10px; color: #bbb;">
             Try different keywords or a broader search term
           </p>`;
      
      document.getElementById('results').innerHTML = `
        <div class="no-results">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M12 12h.01M12 12h.01M12 12h.01M12 12h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          ${message}
        </div>
      `;
    }

    // Utility functions
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function updateStatus(message) {
      document.getElementById('status').textContent = message;
    }

    function showLoading(show) {
      document.getElementById('loading').style.display = show ? 'block' : 'none';
    }

    function showError(message) {
      const errorEl = document.getElementById('error');
      errorEl.textContent = message;
      errorEl.style.display = 'block';
      setTimeout(() => {
        errorEl.style.display = 'none';
      }, 5000);
    }

    // Debounce function
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Handle language filter changes
    function handleLanguageFilterChange(filter) {
      currentLanguageFilter = filter;
      
      // Update button states
      document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.filter === filter);
      });
      
      // Re-run search if there's a query
      if (lastSearchQuery) {
        performSearch(lastSearchQuery);
      }
    }

    // Initialize application
    async function initialize() {
      console.log('Initializing AI Podcast Recommender with Language Filters...');
      
      const searchInput = document.getElementById('search');
      searchInput.disabled = true;
      
      try {
        // Initialize models first
        await initializeModels();
        
        // Set up language filter handlers
        document.querySelectorAll('.filter-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            handleLanguageFilterChange(btn.dataset.filter);
          });
        });
        
        // Set up search handler with debouncing
        const debouncedSearch = debounce(performSearch, CONFIG.DEBOUNCE_DELAY);
        searchInput.addEventListener('input', (e) => {
          const query = e.target.value.trim();
          if (query.length > 0) {
            debouncedSearch(query);
          } else {
            document.getElementById('results').innerHTML = '';
            updateStatus('');
            lastSearchQuery = '';
          }
        });
        
        // Enable search input and focus
        searchInput.disabled = false;
        searchInput.focus();
        
        console.log('Application ready with language filtering!');
        console.log('Excluded languages:', LANGUAGE_FILTERS.EXCLUDED);
        console.log('Simplified Chinese codes:', LANGUAGE_FILTERS.SIMPLIFIED);
        console.log('Traditional Chinese codes:', LANGUAGE_FILTERS.TRADITIONAL);
        
      } catch (error) {
        console.error('Failed to initialize:', error);
        showError('Failed to initialize the application. Please refresh the page.');
      }
    }

    // Start the application when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initialize);
    } else {
      initialize();
    }
  </script>
</body>
</html>
