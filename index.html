<!DOCTYPE html>
<html lang="en">
<head>
Â Â <meta charset="UTF-8" />
Â Â <title>AI Podcast Recommender</title>
Â Â <style>
Â Â Â Â body { font-family: Arial; margin: 30px; background: #fafafa; }
Â Â Â Â h1 { color: #333; }
Â Â Â Â #results div { 
Â Â Â Â Â Â background: white; padding: 12px; 
Â Â Â Â Â Â border-radius: 8px; 
Â Â Â Â Â Â box-shadow: 0 2px 5px rgba(0,0,0,0.1); 
Â Â Â Â Â Â margin-bottom: 14px; 
Â Â Â Â Â Â display: flex; gap: 14px;
Â Â Â Â }
Â Â Â Â img { width: 80px; height: 80px; border-radius: 6px; }
Â Â Â Â input { width: 90%; padding: 12px; border-radius: 6px; border: 1px solid #ccc; font-size: 16px; }
Â Â </style>
</head>
<body>
Â Â <h1>ðŸŽ§ Podcast Recommender</h1>
Â Â <input id="search" placeholder="Search for a topic..." />
Â Â <div id="results"></div>

Â Â <script type="module">
Â Â Â Â import { pipeline } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.6.0';
Â Â Â Â import * as webllm from 'https://esm.run/@mlc-ai/web-llm';

Â Â Â Â // ------------------
Â Â Â Â // GLOBAL PARAMETERS
Â Â Â Â // ------------------
Â Â Â Â const SHARD_COUNT = 200;Â Â Â Â Â // set this to your actual shard number
Â Â Â Â const TOP_K = 10;Â Â Â Â Â Â Â Â Â Â Â Â // keep top-10 before LLM rerank
Â Â Â Â const FINAL_K = 5;Â Â Â Â Â Â Â Â Â Â Â // return top-5 after LLM rerank

Â Â Â Â let embedder;
Â Â Â Â let engine;

Â Â Â Â function delay(ms) { return new Promise(r => setTimeout(r, ms)); }

Â Â Â Â async function main() {
Â Â Â Â Â Â embedder = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
Â Â Â Â Â Â engine = await webllm.CreateWebWorkerMLCEngine(
Â Â Â Â Â Â Â Â new Worker('https://esm.run/@mlc-ai/web-llm/worker'),
Â Â Â Â Â Â Â Â { model: 'Llama-3.2-1B-Instruct-q4f32_1-MLC' }
Â Â Â Â Â Â );

Â Â Â Â Â Â console.log("Models ready.");

Â Â Â Â Â Â const box = document.getElementById("search");
Â Â Â Â Â Â box.addEventListener("input", () => handleInput(box.value));
Â Â Â Â }

Â Â Â Â // Debounce typing
Â Â Â Â let typingTimeout = null;
Â Â Â Â async function handleInput(query) {
Â Â Â Â Â Â if (!query) return;

Â Â Â Â Â Â if (typingTimeout) clearTimeout(typingTimeout);
Â Â Â Â Â Â typingTimeout = setTimeout(() => runSearch(query), 500); // pause 0.5s
Â Â Â Â }

Â Â Â Â // ------------------------
Â Â Â Â // MAIN SEARCH PIPELINE
Â Â Â Â // ------------------------
Â Â Â Â async function runSearch(query) {
Â Â Â Â Â Â console.log("Search query:", query);

Â Â Â Â Â Â const queryEmb = await embedder(query, { pooling: "mean", normalize: true });
Â Â Â Â Â Â const q = queryEmb.data[0];

Â Â Â Â Â Â let topCandidates = []; // global top-K

Â Â Â Â Â Â // STREAM through shards
Â Â Â Â Â Â for (let i = 0; i < SHARD_COUNT; i++) {
Â Â Â Â Â Â Â Â try {
Â Â Â Â Â Â Â Â Â Â const res = await fetch(`shards/shard_${i}.json`);
Â Â Â Â Â Â Â Â Â Â const shard = await res.json();

Â Â Â Â Â Â Â Â Â Â for (const item of shard) {
Â Â Â Â Â Â Â Â Â Â Â Â const score = cosineSimilarity(q, item.embedding);

Â Â Â Â Â Â Â Â Â Â Â Â // Maintain global top-K
Â Â Â Â Â Â Â Â Â Â Â Â if (topCandidates.length < TOP_K) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â topCandidates.push({ ...item, score });
Â Â Â Â Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â topCandidates.sort((a,b) => a.score - b.score); // ascending
Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (score > topCandidates[0].score) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â topCandidates[0] = { ...item, score };
Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â } catch (err) {
Â Â Â Â Â Â Â Â Â Â console.warn("Error loading shard", i, err);
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â // Optional: yield UI thread
Â Â Â Â Â Â Â Â await delay(5);
Â Â Â Â Â Â }

Â Â Â Â Â Â topCandidates.sort((a,b) => b.score - a.score);
Â Â Â Â Â Â const reranked = await rerankWithLLM(query, topCandidates);

Â Â Â Â Â Â displayResults(reranked);
Â Â Â Â }

Â Â Â Â // ------------------------------
Â Â Â Â // LLM RERANK (silent, no output)
Â Â Â Â // ------------------------------
Â Â Â Â async function rerankWithLLM(query, items) {
Â Â Â Â Â Â const list = items.map((p,i) =>
Â Â Â Â Â Â Â Â `${i+1}. ID:${p.episode_id}, Title:${p.title}, Desc:${p.description}`
Â Â Â Â Â Â ).join("\n");

Â Â Â Â Â Â const prompt = `
User query: "${query}"
Pick the best ${FINAL_K} episodes.
Return ONLY a JSON list of episode_ids.

Episodes:
${list}
`;

Â Â Â Â Â Â const response = await engine.chat.completions.create({
Â Â Â Â Â Â Â Â messages: [{ role: "user", content: prompt }],
Â Â Â Â Â Â Â Â temperature: 0.1
Â Â Â Â Â Â });

Â Â Â Â Â Â let output = response.choices[0].message.content;
Â Â Â Â Â Â let ids = [];
Â Â Â Â Â Â try {
Â Â Â Â Â Â Â Â ids = JSON.parse(output.match(/\[.*\]/s)[0]);
Â Â Â Â Â Â } catch {
Â Â Â Â Â Â Â Â console.warn("LLM parse error, fallback");
Â Â Â Â Â Â Â Â ids = items.slice(0, FINAL_K).map(x => x.episode_id);
Â Â Â Â Â Â }

Â Â Â Â Â Â return items.filter(x => ids.includes(x.episode_id));
Â Â Â Â }

Â Â Â Â // -------------------------
Â Â Â Â // UTILS
Â Â Â Â // -------------------------
Â Â Â Â function cosineSimilarity(a, b) {
Â Â Â Â Â Â let dot=0, na=0, nb=0;
Â Â Â Â Â Â for (let i = 0; i < a.length; i++) {
Â Â Â Â Â Â Â Â dot += a[i]*b[i];
Â Â Â Â Â Â Â Â na += a[i]*a[i];
Â Â Â Â Â Â Â Â nb += b[i]*b[i];
Â Â Â Â Â Â }
Â Â Â Â Â Â return dot / (Math.sqrt(na)*Math.sqrt(nb));
Â Â Â Â }

Â Â Â Â function displayResults(results) {
Â Â Â Â Â Â const box = document.getElementById("results");

Â Â Â Â Â Â box.innerHTML = results.map(r => `
Â Â Â Â Â Â Â Â <div>
Â Â Â Â Â Â Â Â Â Â <img src="${r.clean_imageUrl || ''}" />
Â Â Â Â Â Â Â Â Â Â <div>
Â Â Â Â Â Â Â Â Â Â Â Â <a href="${r.link}" target="_blank"><b>${r.title}</b></a>
Â Â Â Â Â Â Â Â Â Â Â Â <p>${r.description}</p>
Â Â Â Â Â Â Â Â Â Â </div>
Â Â Â Â Â Â Â Â </div>
Â Â Â Â Â Â `).join('');
Â Â Â Â }

Â Â Â Â main();
Â Â </script>
</body>
</html>
