<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Podcast Recommender</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 900px;
      margin: 0 auto;
      background: white;
      border-radius: 20px;
      padding: 40px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    
    h1 { 
      color: #333; 
      text-align: center;
      margin-bottom: 10px;
      font-size: 2.5em;
    }
    
    .subtitle {
      text-align: center;
      color: #666;
      margin-bottom: 30px;
    }
    
    .controls-container {
      display: flex;
      gap: 12px;
      margin-bottom: 30px;
      align-items: stretch;
    }
    
    #search-container {
      flex: 1;
      position: relative;
    }
    
    #search { 
      width: 100%; 
      padding: 16px 20px; 
      border-radius: 50px; 
      border: 2px solid #e0e0e0; 
      font-size: 16px; 
      transition: all 0.3s;
      background: #f8f8f8;
      height: 52px;
    }
    
    #search:focus {
      outline: none;
      border-color: #667eea;
      background: white;
      box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
    }
    
    .language-select {
      position: relative;
    }
    
    #language-filter {
      padding: 14px 20px;
      padding-right: 40px;
      border: 2px solid #e0e0e0;
      background: #f8f8f8;
      border-radius: 26px;
      font-size: 15px;
      color: #666;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      transition: all 0.3s;
      min-width: 150px;
      height: 52px;
      font-weight: 500;
    }
    
    #language-filter:focus {
      outline: none;
      border-color: #667eea;
      background: white;
      box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
    }
    
    #language-filter:hover {
      background: #f0f0f0;
    }
    
    .language-select::after {
      content: '‚ñº';
      position: absolute;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
      color: #666;
      font-size: 12px;
    }
    
    #search-button {
      padding: 14px 28px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border: none;
      border-radius: 26px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      height: 52px;
      white-space: nowrap;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    #search-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }
    
    #search-button:active {
      transform: translateY(0);
    }
    
    #search-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    @media (max-width: 768px) {
      .controls-container {
        flex-direction: column;
      }
      
      #search-button {
        width: 100%;
        justify-content: center;
      }
    }
    
    #init-message {
      text-align: center;
      padding: 40px;
      color: #666;
      font-size: 18px;
    }
    
    #loading {
      text-align: center;
      padding: 40px;
      display: none;
    }
    
    .spinner {
      border: 3px solid #f3f3f3;
      border-top: 3px solid #667eea;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    #error {
      background: #fee;
      color: #c33;
      padding: 16px;
      border-radius: 10px;
      margin: 20px 0;
      display: none;
      text-align: center;
    }
    
    #status {
      text-align: center;
      color: #666;
      font-size: 14px;
      margin: 10px 0;
      min-height: 20px;
    }
    
    #results { 
      margin-top: 30px;
    }
    
    .result-item { 
      background: #f9f9f9; 
      padding: 20px; 
      border-radius: 12px; 
      margin-bottom: 16px; 
      display: flex; 
      gap: 16px;
      border: 1px solid #e0e0e0;
      transition: all 0.3s;
    }
    
    .result-item:hover {
      transform: translateX(5px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      background: white;
    }
    
    .podcast-image { 
      width: 80px; 
      height: 80px; 
      border-radius: 8px; 
      object-fit: cover;
      flex-shrink: 0;
      background: #e0e0e0;
    }
    
    .podcast-info {
      flex: 1;
      min-width: 0;
    }
    
    .podcast-title {
      color: #667eea;
      text-decoration: none;
      font-weight: 600;
      font-size: 18px;
      display: block;
      margin-bottom: 8px;
      line-height: 1.3;
    }
    
    .podcast-title:hover {
      text-decoration: underline;
    }
    
    .podcast-description {
      color: #666;
      font-size: 14px;
      line-height: 1.5;
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }
    
    .score-badge {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      align-self: flex-start;
      white-space: nowrap;
    }
    
    .no-results {
      text-align: center;
      padding: 60px 20px;
      color: #999;
      font-size: 18px;
    }
    
    .no-results svg {
      width: 80px;
      height: 80px;
      margin-bottom: 20px;
      opacity: 0.5;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üéß AI Podcast Recommender</h1>
    <p class="subtitle">Search through thousands of podcast episodes using AI</p>
    
    <div class="controls-container">
      <div id="search-container">
        <input 
          id="search" 
          type="text"
          placeholder="Try searching for: technology, comedy, history, science..." 
          autocomplete="off"
        />
      </div>
      <div class="language-select">
        <select id="language-filter">
          <option value="all">All Languages</option>
          <option value="simplified">ÁÆÄ‰Ωì‰∏≠Êñá</option>
          <option value="traditional">ÁπÅÈ´î‰∏≠Êñá</option>
        </select>
      </div>
      <button id="search-button">
        <span>üîç</span>
        <span>Search</span>
      </button>
    </div>
    
    <div id="init-message">
      <div class="spinner"></div>
      Loading AI models... This may take a moment on first visit.
    </div>
    
    <div id="status"></div>
    <div id="loading">
      <div class="spinner"></div>
      Searching podcast database...
    </div>
    <div id="error"></div>
    <div id="results"></div>
  </div>

  <script type="module">
    // Improved configuration for better performance
    const CONFIG = {
      SHARD_COUNT: 200,
      TOP_K: 50,              // Increased from 30 to get better candidates
      FINAL_K: 10,
      DEBOUNCE_DELAY: 600,
      BATCH_SIZE: 10,         // Increased from 5 to load faster
      MODEL_NAME: 'Xenova/paraphrase-multilingual-MiniLM-L12-v2',  // Better multilingual support
      MAX_CONCURRENT_REQUESTS: 6  // Limit browser connection pool
    };

    // Language filter configuration
    const LANGUAGE_FILTERS = {
      EXCLUDED: [
        'zh-rtw', 'zh-hant', 'zh-Hant-', 'zh-Hans-', 'zh-Hant', 
        'en-us,zh', 'zh-US', 'eng, zho', 'zh-sg', 'zh-HK', 'zh-hk', 'zh-Ha'
      ],
      SIMPLIFIED: [
        'zh-CN', 'zh_CN', 'zh-cn', 'zh', 'Zh', 'ZH', 
        'zh-Hans', 'zh-hans', 'zh-ZH', 'zh-zh', 'zho'
      ],
      TRADITIONAL: [
        'zh-tw', 'zh-TW', 'zh_TW', 'zh_tw', 'zh-MO'
      ]
    };

    let embedder = null;
    let isInitializing = false;
    let isSearching = false;
    let searchAbortController = null;
    let currentLanguageFilter = 'all';
    let lastSearchQuery = '';

    // Import transformers library with fallback
    async function loadTransformers() {
      try {
        const { pipeline, env } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2/dist/transformers.min.js');
        
        env.allowLocalModels = false;
        env.useBrowserCache = true;
        env.remoteURL = 'https://huggingface.co/';
        
        return { pipeline, env };
      } catch (error) {
        console.error('Failed to load transformers:', error);
        try {
          const { pipeline, env } = await import('https://unpkg.com/@xenova/transformers@2.17.2/dist/transformers.min.js');
          env.allowLocalModels = false;
          env.useBrowserCache = true;
          return { pipeline, env };
        } catch (fallbackError) {
          throw new Error('Could not load AI models from any CDN');
        }
      }
    }

    // Initialize the embedding model
    async function initializeModels() {
      if (isInitializing || embedder) return embedder;
      
      isInitializing = true;
      const initMessage = document.getElementById('init-message');
      
      try {
        const { pipeline } = await loadTransformers();
        
        console.log('Loading multilingual embedding model...');
        embedder = await pipeline('feature-extraction', CONFIG.MODEL_NAME);
        
        console.log('Model loaded successfully');
        initMessage.style.display = 'none';
        document.getElementById('search').disabled = false;
        updateStatus('Ready to search! Start typing...');
        
        return embedder;
      } catch (error) {
        console.error('Model initialization failed:', error);
        initMessage.innerHTML = `
          <div style="color: #e74c3c;">
            <p><strong>Failed to load AI models</strong></p>
            <p style="margin-top: 10px; font-size: 14px;">
              ${error.message}<br>
              Please check your internet connection and refresh the page.
            </p>
          </div>
        `;
        document.getElementById('search').disabled = true;
        throw error;
      } finally {
        isInitializing = false;
      }
    }

    // Check if an item should be filtered based on language
    function shouldIncludeItem(item) {
      const itemLanguage = (item.language || '').toLowerCase().trim();
      
      for (const excluded of LANGUAGE_FILTERS.EXCLUDED) {
        if (itemLanguage === excluded.toLowerCase()) {
          return false;
        }
      }
      
      if (currentLanguageFilter === 'all') {
        return true;
      }
      
      if (currentLanguageFilter === 'simplified') {
        for (const lang of LANGUAGE_FILTERS.SIMPLIFIED) {
          if (itemLanguage === lang.toLowerCase()) {
            return true;
          }
        }
        return false;
      }
      
      if (currentLanguageFilter === 'traditional') {
        for (const lang of LANGUAGE_FILTERS.TRADITIONAL) {
          if (itemLanguage === lang.toLowerCase()) {
            return true;
          }
        }
        return false;
      }
      
      return true;
    }

    // Calculate cosine similarity between two vectors
    function cosineSimilarity(a, b) {
      if (!a || !b || a.length !== b.length) return 0;
      
      let dotProduct = 0;
      let normA = 0;
      let normB = 0;
      
      for (let i = 0; i < a.length; i++) {
        dotProduct += a[i] * b[i];
        normA += a[i] * a[i];
        normB += b[i] * b[i];
      }
      
      if (normA === 0 || normB === 0) return 0;
      return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
    }

    // Load a shard file with retry logic
    async function loadShard(shardId, retries = 2) {
      for (let i = 0; i <= retries; i++) {
        try {
          const response = await fetch(`shards/shard_${shardId}.json`, {
            cache: 'force-cache'
          });
          
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          
          const data = await response.json();
          return { shardId, data, error: null };
        } catch (error) {
          if (i === retries) {
            console.warn(`Failed to load shard_${shardId} after ${retries + 1} attempts`);
            return { shardId, data: null, error };
          }
          await new Promise(resolve => setTimeout(resolve, 100 * (i + 1)));
        }
      }
    }

    // Improved keyword-based search for Chinese queries
    function keywordSearch(query, items) {
      const queryLower = query.toLowerCase();
      const queryChars = query.split('');
      
      return items.map(item => {
        let score = 0;
        
        const title = (item.title || '').toLowerCase();
        const desc = (item.description || '').toLowerCase();
        const creator = (item.creator || '').toLowerCase();
        
        // Exact match
        if (title.includes(query)) score += 10;
        if (desc.includes(query)) score += 5;
        if (creator.includes(query)) score += 3;
        
        // Character-by-character matching for Chinese
        let charMatches = 0;
        for (const char of queryChars) {
          if (title.includes(char)) charMatches++;
        }
        score += charMatches * 0.5;
        
        // Word boundary matching (for English)
        const queryWords = queryLower.split(/\s+/).filter(w => w.length > 1);
        for (const word of queryWords) {
          if (title.includes(word)) score += 2;
          if (desc.includes(word)) score += 1;
        }
        
        return {
          ...item,
          keywordScore: score
        };
      }).filter(item => item.keywordScore > 0)
        .sort((a, b) => b.keywordScore - a.keywordScore);
    }

    // Main search function with optimizations
    async function performSearch(query) {
      if (!query || query.trim().length < 2) {
        document.getElementById('results').innerHTML = '';
        updateStatus('');
        return;
      }

      lastSearchQuery = query;

      if (searchAbortController) {
        searchAbortController.abort();
      }
      searchAbortController = new AbortController();

      if (isSearching) return;
      isSearching = true;

      showLoading(true);
      updateStatus('');
      document.getElementById('results').innerHTML = '';

      try {
        if (!embedder) {
          await initializeModels();
          if (!embedder) return;
        }

        console.log('Query:', query);
        console.log('Language filter:', currentLanguageFilter);
        
        // Generate query embedding
        const output = await embedder(query, { 
          pooling: 'mean', 
          normalize: true 
        });
        
        const queryVector = Array.from(output.data);
        
        console.log('Searching shards...');
        
        const topResults = [];
        let processedShards = 0;
        let totalItems = 0;
        let filteredCount = 0;
        let failedShards = 0;
        
        // Store all filtered items for keyword fallback
        const allFilteredItems = [];

        // Process shards with controlled concurrency
        for (let i = 0; i < CONFIG.SHARD_COUNT; i += CONFIG.BATCH_SIZE) {
          if (searchAbortController.signal.aborted) break;
          
          const batch = [];
          const batchSize = Math.min(CONFIG.BATCH_SIZE, CONFIG.SHARD_COUNT - i);
          
          for (let j = i; j < i + batchSize; j++) {
            batch.push(loadShard(j));
          }
          
          const shardResults = await Promise.all(batch);
          
          for (const { shardId, data, error } of shardResults) {
            if (error) {
              failedShards++;
              continue;
            }
            
            if (!data || !Array.isArray(data)) continue;
            
            processedShards++;
            
            for (const item of data) {
              if (!item || !item.embedding || !Array.isArray(item.embedding)) continue;
              
              totalItems++;
              
              // Apply language filter
              if (!shouldIncludeItem(item)) {
                filteredCount++;
                continue;
              }
              
              // Store for keyword search
              allFilteredItems.push(item);
              
              const score = cosineSimilarity(queryVector, item.embedding);
              
              if (topResults.length < CONFIG.TOP_K) {
                topResults.push({ ...item, score, shardId });
              } else {
                let minIdx = 0;
                for (let k = 1; k < topResults.length; k++) {
                  if (topResults[k].score < topResults[minIdx].score) {
                    minIdx = k;
                  }
                }
                if (score > topResults[minIdx].score) {
                  topResults[minIdx] = { ...item, score, shardId };
                }
              }
            }
          }
          
          // Update progress every 20 shards or at end
          if (processedShards % 20 === 0 || processedShards === CONFIG.SHARD_COUNT) {
            const filterText = currentLanguageFilter !== 'all' 
              ? ` (${filteredCount} filtered)` 
              : '';
            updateStatus(`Searched ${processedShards}/${CONFIG.SHARD_COUNT} shards${filterText}...`);
          }
        }

        console.log(`Search complete: ${processedShards} shards, ${totalItems} items, ${filteredCount} filtered, ${failedShards} failed`);
        
        if (topResults.length === 0) {
          displayNoResults(filteredCount > 0);
          return;
        }

        // Sort by similarity score
        topResults.sort((a, b) => b.score - a.score);
        
        // Hybrid reranking: combine semantic similarity with keyword matching
        const reranked = hybridRerank(query, topResults, allFilteredItems);
        
        displayResults(reranked.slice(0, CONFIG.FINAL_K));
        
        const filterInfo = currentLanguageFilter !== 'all' 
          ? ` (${filteredCount} filtered)` 
          : '';
        updateStatus(`Found ${reranked.length} relevant podcasts${filterInfo}`);
        
      } catch (error) {
        console.error('Search error:', error);
        showError('Search failed. Please try again.');
      } finally {
        showLoading(false);
        isSearching = false;
        searchAbortController = null;
      }
    }

    // Hybrid reranking combining semantic and keyword search
    function hybridRerank(query, semanticResults, allItems) {
      // Get keyword-based results
      const keywordResults = keywordSearch(query, allItems.slice(0, 1000)); // Limit for performance
      
      // Create a map of keyword scores
      const keywordScores = new Map();
      keywordResults.forEach(item => {
        const key = `${item.title}|${item.creator}`;
        keywordScores.set(key, item.keywordScore);
      });
      
      // Combine scores
      return semanticResults.map(item => {
        const key = `${item.title}|${item.creator}`;
        const keywordScore = keywordScores.get(key) || 0;
        
        // Weight semantic similarity more for English, keywords more for Chinese
        const hasChinese = /[\u4e00-\u9fa5]/.test(query);
        const semanticWeight = hasChinese ? 0.3 : 0.7;
        const keywordWeight = hasChinese ? 0.7 : 0.3;
        
        // Normalize scores to 0-1 range
        const normalizedSemantic = item.score; // Already normalized
        const normalizedKeyword = Math.min(keywordScore / 20, 1); // Scale keyword score
        
        const finalScore = (normalizedSemantic * semanticWeight) + (normalizedKeyword * keywordWeight);
        
        return {
          ...item,
          keywordScore,
          finalScore
        };
      }).sort((a, b) => b.finalScore - a.finalScore);
    }

    // Display search results
    function displayResults(results) {
      const container = document.getElementById('results');
      
      if (!results || results.length === 0) {
        displayNoResults(false);
        return;
      }
      
      container.innerHTML = results.map(item => {
        const imageUrl = item.image || 
          'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjgwIiBmaWxsPSIjZTBlMGUwIi8+CiAgPHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIzMCIgZmlsbD0iIzk5OSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZG9taW5hbnQtYmFzZWxpbmU9Im1pZGRsZSI+8J+OpjwvdGV4dD4KPC9zdmc+';
        
        const title = item.title || 'Untitled Episode';
        const description = cleanDescription(item.description || 'No description available');
        const creator = item.creator || '';
        const link = item.link || '#';
        const score = Math.round((item.finalScore || item.score || 0) * 100);
        
        const creatorInfo = creator ? `<span style="color: #888; font-size: 12px; display: block; margin-top: 4px;">by ${escapeHtml(creator)}</span>` : '';
        
        return `
          <div class="result-item">
            <img 
              src="${imageUrl}" 
              alt="${title}" 
              class="podcast-image"
              loading="lazy"
              onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjgwIiBmaWxsPSIjZTBlMGUwIi8+CiAgPHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIzMCIgZmlsbD0iIzk5OSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZG9taW5hbnQtYmFzZWxpbmU9Im1pZGRsZSI+8J+OpjwvdGV4dD4KPC9zdmc+'"
            />
            <div class="podcast-info">
              <a href="${link}" target="_blank" rel="noopener noreferrer" class="podcast-title">
                ${escapeHtml(title)}
              </a>
              ${creatorInfo}
              <p class="podcast-description">${escapeHtml(description)}</p>
            </div>
            <div class="score-badge">${score}%</div>
          </div>
        `;
      }).join('');
    }

    function displayNoResults(hasFilteredResults = false) {
      const message = hasFilteredResults 
        ? `<p>No matching podcasts found with current language filter</p>
           <p style="font-size: 14px; margin-top: 10px; color: #bbb;">
             Try selecting "All" languages or different search terms
           </p>`
        : `<p>No matching podcasts found</p>
           <p style="font-size: 14px; margin-top: 10px; color: #bbb;">
             Try different keywords or a broader search term
           </p>`;
      
      document.getElementById('results').innerHTML = `
        <div class="no-results">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M12 12h.01M12 12h.01M12 12h.01M12 12h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          ${message}
        </div>
      `;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    function cleanDescription(text) {
      if (!text) return '';
      let cleaned = text.replace(/<[^>]*>/g, '');
      const textarea = document.createElement('textarea');
      textarea.innerHTML = cleaned;
      cleaned = textarea.value;
      cleaned = cleaned.replace(/\s+/g, ' ').trim();
      return cleaned;
    }

    function updateStatus(message) {
      document.getElementById('status').textContent = message;
    }

    function showLoading(show) {
      document.getElementById('loading').style.display = show ? 'block' : 'none';
    }

    function showError(message) {
      const errorEl = document.getElementById('error');
      errorEl.textContent = message;
      errorEl.style.display = 'block';
      setTimeout(() => {
        errorEl.style.display = 'none';
      }, 5000);
    }

    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    function handleLanguageFilterChange(filter) {
      currentLanguageFilter = filter;
      if (lastSearchQuery) {
        performSearch(lastSearchQuery);
      }
    }

    async function initialize() {
      console.log('Initializing AI Podcast Recommender (Improved)...');
      
      const searchInput = document.getElementById('search');
      const searchButton = document.getElementById('search-button');
      const languageFilter = document.getElementById('language-filter');
      
      searchInput.disabled = true;
      searchButton.disabled = true;
      
      try {
        await initializeModels();
        
        languageFilter.addEventListener('change', (e) => {
          handleLanguageFilterChange(e.target.value);
        });
        
        const triggerSearch = () => {
          const query = searchInput.value.trim();
          if (query.length > 0) {
            performSearch(query);
          } else {
            document.getElementById('results').innerHTML = '';
            updateStatus('Please enter a search term');
          }
        };
        
        searchButton.addEventListener('click', triggerSearch);
        
        searchInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            triggerSearch();
          }
        });
        
        const debouncedSearch = debounce(performSearch, CONFIG.DEBOUNCE_DELAY);
        searchInput.addEventListener('input', (e) => {
          const query = e.target.value.trim();
          if (query.length > 0) {
            debouncedSearch(query);
          } else {
            document.getElementById('results').innerHTML = '';
            updateStatus('');
            lastSearchQuery = '';
          }
        });
        
        searchInput.disabled = false;
        searchButton.disabled = false;
        searchInput.focus();
        
        console.log('Application ready with improved Chinese support!');
        
      } catch (error) {
        console.error('Failed to initialize:', error);
        showError('Failed to initialize the application. Please refresh the page.');
      }
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initialize);
    } else {
      initialize();
    }
  </script>
</body>
</html>
